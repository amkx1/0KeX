{
  "blogs": [
    {
      "id": 1,
      "title": "Aliens Eat Snacks - BITSCTF 2026",
      "excerpt": "We were given three files-",
      "content": "<h2>Challenge Overview</h2><p>We were given three files-</p><ul><li><code>aes.py</code> - custom AES-like encryption implementation</li><li><code>output.txt</code> - contains key hint,  encrypted flag and 1000 known plaintext/ciphertext sample pairs</li><li><code>README.md</code> - has a quick description of the challenge</li></ul><hr><h2>Analysing the AES Implementation</h2><p>First thing we do is read the <code>aes.py</code> file carefully and compare it with the standard AES. Here’s what stood out:</p><p><strong>Custom S-box:</strong><strong> </strong>Standard AES builds its S-box using the multiplicative inverse in GF(2⁸), i.e <code>gf_pow(x, 254)</code>. This implementation uses:</p><pre><code class='language-python'>def generate_sbox():\n    return [gf_pow(x, 23) ^ 0x63 for x in range(256)]</code></pre><p>It uses the exponent 23 instead of 254 hence producing a non-standard and much weaker S-box.</p><p><strong>Reduced Rounds:</strong><strong> </strong>Standard AES-128 runs 10 rounds. This implementation only runs <strong>4 rounds</strong>, significantly reducing diffusion and making the cipher easier to attack.</p><p><strong>No mode of operation:</strong><strong> </strong>The cipher operates in raw ECB mode, each 16-byte block is encrypted independently with no IV or chaining. </p><h2><strong>The Key Hint</strong></h2><p>The key hint provided was: <code>26ab77cadcca0ed41b03c8f2e5</code></p><p>Converting from hex to bytes gives <strong>13 bytes</strong>. A standard AES-128 key requires <strong>16 bytes</strong>. This means <strong>3 bytes of the key are missing</strong>.</p><p>The search space for 3 unknown bytes is <strong>256³ =</strong> <strong>16,777,216 combinations, </strong>large but feasible to brute force, especially since we have 1000 known plaintext/ciphertext pairs to verify candidates against.</p><h2><strong>Known Plaintext Brute Force</strong></h2><p>The <code>output.txt</code> file contained 1000 sample lines in the format:</p><p><code>plaintext_hex, ciphertext_hex</code> </p><p>We opt for the following strategy:</p><ul><li>Assume the 3 missing bytes are <strong>appended</strong> to the end of the 13-byte hint to form the full 16-byte key.</li><li>Iterate through all 256³ possible 3-byte combinations.</li><li>For each candidate key, encrypt the first sample's plaintext and check if it matches the known ciphertext.</li><li>If it matches, verify with a second sample to rule out false positives.</li><li>Once the key is confirmed, use it to decrypt the encrypted flag.</li></ul><h2>The Decryption Script</h2><p>Our script used the AES implementation from <code>aes.py</code> directly and performed the brute force:</p><pre><code class='language-python'>KEY_HINT = bytes.fromhex(\"26ab77cadcca0ed41b03c8f2e5\")  # 13 bytes\n\nfor b1, b2, b3 in itertools.product(range(256), repeat=3):\n    candidate_key = KEY_HINT + bytes([b1, b2, b3])\n    rk = key_expansion(candidate_key, ROUNDS)\n\n    if encrypt_block(pt0, rk) == ct0:\n        if encrypt_block(pt1, rk) == ct1:\n            print(f\"[+] Key found: {candidate_key.hex()}\")\n            # Decrypt the flag...</code></pre><p>The encrypted flag was of 64 bytes(4 blocks of 16 bytes), so each block was decrypted independently:</p><pre><code class='language-python'>flag = b\"\"\nfor i in range(0, len(ENCRYPTED_FLAG), 16):\n    block = ENCRYPTED_FLAG[i:i+16]\n    flag += decrypt_block(block, round_keys)</code></pre><p>We find the correct key after running the script and the flag was successfully decrypted: <code>BITSCTF{7h3_qu1ck_br0wn_f0x_jump5_0v3r_7h3_l4zy_d0g}</code></p><hr><h2>Summary</h2><ul><li><strong>Incomplete Key:</strong> Only 13 of 16 key bytes provided, 3 bytes brute forced</li><li><strong>Weak S-box:</strong> Uses <code>gf_pow(x, 23)</code> instead of standard multiplicative inverse</li><li><strong>Reduced Rounds:</strong> 4 rounds instead of standard 10</li><li><strong>Known plaintexts:</strong> 1000 sample pairs provided, allowing quick key verification</li></ul>",
      "date": "Feb 23, 2026",
      "category": "CTF",
      "tags": [
        "ctfs",
        "writeup",
        "aes",
        "cryptography"
      ]
    },
    {
      "id": 2,
      "title": "Hello World",
      "excerpt": "This site is my personal space to learn, build, break things, and document the process.",
      "content": "<p>Hi there! If it’s your first time here, I’m happy to have you! If not, thank you for coming again!\nYou all are awesome!</p><p>This site is my personal space to <strong>learn, build, break things, and document the process.</strong></p><p>Right now, I’m a student deeply interested in <strong>technology, backend systems, and cybersecurity</strong>. I don’t claim to know everything. In fact, this blog exists because <strong>I don’t</strong> and I believe learning in public is one of the best ways to grow and also hold myself accountable.</p><h1>What will you find here?</h1><p>On this site you’ll mostly find-</p><ul><li>Breakdown of recent concepts I’ve learned</li><li>The working on projects I built or am building</li><li>Writeups on Labs, challenges or CTFs</li><li>My personal notes, experiences and everything I come across</li><li>Probably some studies and breakdown on recent news as well</li></ul><p>Now I’m not an expert and everything will not be perfect but this is more for myself than anyone. I believe this will help me track my progress and feel accomplished as well.</p><p>And as I am teaching myself, I hope this can help you or inspire you from my journey as well. </p><p>If you’re reading this early, as this is THE first post on here, I love you! You are a part of this foundation being built, even just as my reader. Thank you soo much for stopping by.</p><p>Let’s see how this goes!</p>",
      "date": "Jan 31, 2026",
      "category": "misc",
      "tags": []
    }
  ]
}